{% extends "base.html" %}

{% block title %}Planilla de Planta{% endblock %}

{% block navbar_brand_text %}Planilla Planta{% endblock %}

{% block main_style %}
    /* Estilo para el fondo del área principal (<main>) */
    background-image: url('{{ url_for('static', filename='logo.jpeg') }}');
    background-repeat: repeat;
    background-size: 120px auto;
    background-color: #e9ecef;
{% endblock %}

{% block content %}
<div class="container-fluid">

    <div class="page-section-header shadow-sm">
        <h1 class="mb-0 h2 page-title-text">
            <i class="bi bi-clipboard-data-fill page-title-icon"></i> Planilla de Planta
        </h1>
    </div>

    <div class="action-buttons-bar text-center my-3">
        <div class="btn-group me-2" role="group">
            <button id="btnGuardarRegistro" onclick="guardarRegistro()" class="btn btn-success btn-lg px-4">
                <i class="bi bi-save2-fill"></i> Guardar Registro del Día
            </button>
        </div>
        <div class="btn-group" role="group">
            <a href="{{ url_for('reporte_planta') }}" class="btn btn-info btn-lg text-white px-4">
                <i class="bi bi-file-earmark-bar-graph-fill"></i> Ver Reporte
            </a>
        </div>
    </div>
    {# El div para el aviso de hora límite se insertará aquí por JS si es necesario #}

    <div id="alert-container" style="position: fixed; top: calc(4.5rem + 20px); right: 20px; z-index: 1050; width: auto; max-width: 400px;"></div>

    <div class="table-container shadow-sm">
        <div class="table-responsive">
            <table class="table table-bordered table-striped table-hover table-sm align-middle">
                <thead class="sticky-top table-header-custom">
                    <tr>
                        <th style="min-width: 100px;">TK</th>
                        <th style="min-width: 150px;">PRODUCTO</th>
                        <th style="min-width: 120px;">MAX. CAP</th>
                        <th style="min-width: 120px;">BLS @60</th>
                        <th style="min-width: 100px;">API</th>
                        <th style="min-width: 100px;">%BSW</th>
                        <th style="min-width: 100px;">%S</th>
                    </tr>
                </thead>
                <tbody>
                    {% for fila in planilla %}
                    <tr data-tk="{{ fila.TK }}">
                        <td>{{ fila.TK }}</td>
                        <td>{{ fila.PRODUCTO }}</td>
                        <td>{{ fila.MAX_CAP }}</td>
                        <td contenteditable="true" class="editable" data-field="BLS_60" inputmode="decimal">{{ fila.BLS_60 }}</td>
                        <td contenteditable="true" class="editable" data-field="API" inputmode="decimal">{{ fila.API }}</td>
                        <td contenteditable="true" class="editable" data-field="BSW" inputmode="decimal">{{ fila.BSW }}</td>
                        <td contenteditable="true" class="editable" data-field="S" inputmode="decimal">{{ fila.S }}</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>

<style>
    .page-section-header {
        background-color: rgba(255, 255, 255, 0.97);
        padding: 1rem 1.5rem;
        border-radius: 0.375rem;
        margin-bottom: 0; 
        text-align: center; 
    }

    .page-title-text {
        color: #343a40;
        font-weight: 600; 
    }
    .page-title-icon {
        color: #0b8552;
        font-size: 1.1em;
        margin-right: 0.5rem;
    }
    .action-buttons-bar {
        padding-top: 1rem; 
        padding-bottom: 1rem; 
    }
    .action-buttons-bar .btn-lg { 
        padding-left: 1.5rem;
        padding-right: 1.5rem;
    }
    .table-container {
        background-color: rgba(255, 255, 255, 0.95);
        padding: 1.5rem; 
        border-radius: 0.375rem;
        margin-top: 1.5rem; 
    }
    .table-header-custom {
        background-color: #0b8552 !important;
        color: white !important;
    }
    .table-responsive thead.sticky-top th {
        position: sticky;
        top: 0; 
        z-index: 1; 
    }
    .editable {
        background-color: #fef9e7; 
        cursor: text;
    }
    .editable:hover {
        background-color: #fdecb3; 
    }
    .editable:focus {
        background-color: #fcf3cf; 
        outline: 2px solid #0b8552; 
        box-shadow: 0 0 5px rgba(11, 133, 82, 0.5);
    }
    /* Estilo para el aviso de hora límite */
    .aviso-hora-limite {
        font-size: 0.9rem;
        padding: 0.75rem 1.25rem;
        margin-bottom: 1rem;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }
    /* NUEVO: Estilo para celdas no editables después de la hora límite */
    .celda-no-editable {
        background-color: #e9ecef !important; /* Color de fondo neutro, similar al de la página */
        cursor: default !important;
        color: #6c757d; /* Texto un poco más claro para indicar inactividad */
    }
    .celda-no-editable:hover,
    .celda-no-editable:focus {
        background-color: #e9ecef !important;
        outline: none !important;
        box-shadow: none !important;
    }

</style>

<script>
    function mostrarAlerta(mensaje, tipo = 'info', duracion = 4000) {
        const alertContainer = document.getElementById('alert-container');
        if (!alertContainer) { console.error("Contenedor de alertas no encontrado."); return; }
        const wrapper = document.createElement('div');
        let iconClass = 'bi-info-circle-fill';
        if (tipo === 'success') iconClass = 'bi-check-circle-fill';
        if (tipo === 'danger') iconClass = 'bi-exclamation-triangle-fill';
        if (tipo === 'warning') iconClass = 'bi-exclamation-diamond-fill';
        wrapper.innerHTML = `<div class="alert alert-${tipo} alert-dismissible fade show d-flex align-items-center" role="alert"><i class="bi ${iconClass} me-2"></i><div>${mensaje}</div><button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button></div>`;
        alertContainer.appendChild(wrapper);
        const alertElement = wrapper.firstChild;
        if (alertElement) {
            setTimeout(() => {
                const alertInstance = bootstrap.Alert.getOrCreateInstance(alertElement);
                if (alertInstance) { alertInstance.close(); }
                else if (wrapper.parentElement) { wrapper.remove(); }
            }, duracion);
        }
    }

    document.addEventListener("DOMContentLoaded", function () {
        const editableCells = document.querySelectorAll(".editable");
        let edicionPermitida = true; // Variable para controlar si la edición está permitida

        // --- INICIO: LÓGICA PARA VERIFICAR HORA Y DESHABILITAR FUNCIONALIDADES ---
        const btnGuardarRegistro = document.getElementById('btnGuardarRegistro');
        const ahora = new Date();
        const horaActual = ahora.getHours(); 
        const HORA_LIMITE_REGISTRO = 10; 

        if (horaActual >= HORA_LIMITE_REGISTRO) {
            edicionPermitida = false; // La edición ya no está permitida

            if (btnGuardarRegistro) {
                btnGuardarRegistro.disabled = true;
                btnGuardarRegistro.classList.remove('btn-success');
                btnGuardarRegistro.classList.add('btn-secondary');
                
                const avisoDiv = document.createElement('div');
                avisoDiv.innerHTML = `
                    <div class="alert alert-warning text-center aviso-hora-limite" role="alert">
                        <i class="bi bi-clock-fill me-2"></i>Los registros para hoy se aceptan únicamente antes de las ${HORA_LIMITE_REGISTRO}:00 AM. La planilla está bloqueada.
                    </div>
                `;
                const actionButtonsBar = document.querySelector('.action-buttons-bar');
                if (actionButtonsBar && actionButtonsBar.parentNode) {
                    actionButtonsBar.parentNode.insertBefore(avisoDiv, actionButtonsBar.nextSibling);
                }
            }

            // Hacer que las celdas "editables" dejen de serlo
            editableCells.forEach(cell => {
                cell.contentEditable = false;
                // Quitar la clase 'editable' que da el estilo amarillo y hover
                cell.classList.remove('editable');
                // Añadir una nueva clase para el estilo de celda no editable
                cell.classList.add('celda-no-editable');
            });
        }
        // --- FIN: LÓGICA PARA VERIFICAR HORA ---


        // Lógica para celdas editables y guardado individual
        // Solo se adjuntan los listeners si la edición está permitida inicialmente
        // O, si queremos que los listeners estén siempre pero verifiquen 'edicionPermitida' internamente
        // Para este caso, si edicionPermitida es false desde el inicio, los listeners de abajo no se activarán
        // de forma que impidan la edición.
        
        editableCells.forEach(cell => {
            // Los listeners de keydown y paste solo tienen efecto si contentEditable es true
            cell.addEventListener('keydown', function(event) {
                if (!edicionPermitida || !cell.isContentEditable) { event.preventDefault(); return; } // Bloquear si no se permite editar

                const allowedKeys = ["Backspace", "Delete", "Tab", "Escape", "Enter", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"];
                if (allowedKeys.includes(event.key)) { return; }
                if ((event.ctrlKey || event.metaKey) && ['a', 'c', 'v', 'x', 'z'].includes(event.key.toLowerCase())) { return; }
                if ((event.key >= '0' && event.key <= '9')) { return; }
                if (event.key === ',' || event.key === '.') { 
                    if (cell.innerText.includes(',') || cell.innerText.includes('.')) { event.preventDefault(); }
                    return; 
                }
                event.preventDefault();
            });

            cell.addEventListener('paste', function(event) {
                if (!edicionPermitida || !cell.isContentEditable) { event.preventDefault(); return; } // Bloquear si no se permite editar

                event.preventDefault();
                let paste = (event.clipboardData || window.clipboardData).getData('text');
                paste = paste.replace(/[^\d,.]/g, '').replace(/([,.])(?=.*[,.])/g, ''); 
                document.execCommand('insertText', false, paste);
            });

            cell.addEventListener("blur", () => {
                // Aunque la celda se haya vuelto no editable, el evento blur aún puede dispararse.
                // Pero si la celda ya no es 'editable' (contentEditable=false), el usuario no habrá podido cambiar el valor.
                // Sin embargo, para el guardado de celda individual, idealmente la restricción de hora también debería estar en el backend.
                if (!edicionPermitida && !cell.isContentEditable) { // Doble chequeo, aunque el if de arriba lo haría no editable.
                     // Si se hizo no editable por la hora, no intentar guardar al hacer blur.
                    return;
                }
                // Si la celda aún tiene la clase 'editable' y es contentEditable (antes de las 10 AM)
                if (!cell.classList.contains('celda-no-editable') && cell.isContentEditable) {
                    const row = cell.closest("tr"); if (!row) return;
                    const tk = row.dataset.tk; const field = cell.dataset.field; 
                    let value = cell.innerText.trim().replace(',', '.'); 

                    fetch("{{ url_for('guardar_datos_planta') }}", {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ tk, field, value: value })
                    })
                    .then(res => { if (!res.ok) { return res.json().then(errData => { throw errData || new Error("Error HTTP: " + res.status); }); } return res.json(); })
                    .then(data => {
                        if (data.success) { 
                            cell.classList.add('border-success', 'border-2'); 
                            setTimeout(()=> { cell.classList.remove('border-success', 'border-2'); }, 1500); 
                        } else { 
                            mostrarAlerta("Error al guardar celda: " + (data.message || "Error desconocido"), "danger"); 
                        }
                    })
                    .catch(err => { 
                        console.error("Error fetch (guardar celda):", err); 
                        mostrarAlerta("Error al guardar celda: " + (err.message || "Error de conexión."), "danger"); 
                    });
                }
            });
        });
    }); // Fin de DOMContentLoaded

    function guardarRegistro() {
        // El botón ya debería estar deshabilitado si es después de las 10 AM,
        // por lo que esta función no debería ser llamada.
        // Pero como una doble seguridad, podemos verificar aquí también.
        const ahora = new Date();
        if (ahora.getHours() >= 10) { // HORA_LIMITE_REGISTRO es 10
            mostrarAlerta("❌ Los registros están cerrados después de las 10:00 AM.", "warning");
            return;
        }

        mostrarAlerta("Guardando registro, por favor espera...", "info", 6000);
        fetch("{{ url_for('guardar_registro_planta') }}", { method: "POST" })
        .then(res => { 
            if (!res.ok) { 
                return res.json().then(errData => { 
                    const error = new Error(errData.message || "Error HTTP: " + res.status);
                    error.data = errData; 
                    throw error; 
                }); 
            } 
            return res.json(); 
        })
        .then(data => {
            if (data.success) { 
                mostrarAlerta("✅ ¡Registro guardado exitosamente!", "success"); 
                setTimeout(() => { window.location.href = "{{ url_for('reporte_planta') }}"; }, 1500); 
            } else { 
                mostrarAlerta("❌ Error al guardar registro: " + (data.message || "Error desconocido"), "danger"); 
            }
        })
        .catch(err => { 
            console.error("Error de red o al procesar (guardar registro):", err); 
            const errorMessage = err.data && err.data.message ? err.data.message : (err.message || "Error de red o al procesar la respuesta.");
            mostrarAlerta("❌ " + errorMessage, "danger"); 
        });
    }
</script>
{% endblock %}